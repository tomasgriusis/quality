/* soapStub.h
   Generated by gSOAP 2.8.16 from damis.h

Copyright(C) 2000-2013, Robert van Engelen, Genivia Inc. All Rights Reserved.
The generated code is released under one of the following licenses:
GPL or Genivia's license for commercial use.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
*/

#ifndef soapStub_H
#define soapStub_H
#include <vector>
#define SOAP_NAMESPACE_OF_Damis	"DAMIS"
#include "stdsoap2.h"
#if GSOAP_VERSION != 20816
# error "GSOAP VERSION MISMATCH IN GENERATED CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#if 0 /* volatile type: do not declare here, declared elsewhere */

#endif

#ifndef SOAP_TYPE_Damis__PCAResponse
#define SOAP_TYPE_Damis__PCAResponse (8)
/* Damis:PCAResponse */
struct Damis__PCAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 8; } /* = unique id SOAP_TYPE_Damis__PCAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__PCA
#define SOAP_TYPE_Damis__PCA (14)
/* Damis:PCA */
struct Damis__PCA
{
public:
	std::string X;	/* required element of type xsd:string */
	bool projType;	/* required element of type xsd:boolean */
	double d;	/* required element of type xsd:double */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 14; } /* = unique id SOAP_TYPE_Damis__PCA */
};
#endif

#ifndef SOAP_TYPE_Damis__SMACOFMDSResponse
#define SOAP_TYPE_Damis__SMACOFMDSResponse (15)
/* Damis:SMACOFMDSResponse */
struct Damis__SMACOFMDSResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 15; } /* = unique id SOAP_TYPE_Damis__SMACOFMDSResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__SMACOFMDS
#define SOAP_TYPE_Damis__SMACOFMDS (18)
/* Damis:SMACOFMDS */
struct Damis__SMACOFMDS
{
public:
	std::string X;	/* required element of type xsd:string */
	int d;	/* required element of type xsd:int */
	int maxIteration;	/* required element of type xsd:int */
	double eps;	/* required element of type xsd:double */
	bool zeidel;	/* required element of type xsd:boolean */
	int p;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 18; } /* = unique id SOAP_TYPE_Damis__SMACOFMDS */
};
#endif

#ifndef SOAP_TYPE_Damis__DMAResponse
#define SOAP_TYPE_Damis__DMAResponse (19)
/* Damis:DMAResponse */
struct Damis__DMAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 19; } /* = unique id SOAP_TYPE_Damis__DMAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__DMA
#define SOAP_TYPE_Damis__DMA (22)
/* Damis:DMA */
struct Damis__DMA
{
public:
	std::string X;	/* required element of type xsd:string */
	int d;	/* required element of type xsd:int */
	int maxIteration;	/* required element of type xsd:int */
	double eps;	/* required element of type xsd:double */
	double neighbour;	/* required element of type xsd:double */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 22; } /* = unique id SOAP_TYPE_Damis__DMA */
};
#endif

#ifndef SOAP_TYPE_Damis__RELMDSResponse
#define SOAP_TYPE_Damis__RELMDSResponse (23)
/* Damis:RELMDSResponse */
struct Damis__RELMDSResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 23; } /* = unique id SOAP_TYPE_Damis__RELMDSResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__RELMDS
#define SOAP_TYPE_Damis__RELMDS (26)
/* Damis:RELMDS */
struct Damis__RELMDS
{
public:
	std::string X;	/* required element of type xsd:string */
	int d;	/* required element of type xsd:int */
	int maxIteration;	/* required element of type xsd:int */
	double eps;	/* required element of type xsd:double */
	double noOfBaseVectors;	/* required element of type xsd:double */
	int selStrategy;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 26; } /* = unique id SOAP_TYPE_Damis__RELMDS */
};
#endif

#ifndef SOAP_TYPE_Damis__SAMANNResponse
#define SOAP_TYPE_Damis__SAMANNResponse (27)
/* Damis:SAMANNResponse */
struct Damis__SAMANNResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 27; } /* = unique id SOAP_TYPE_Damis__SAMANNResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__SAMANN
#define SOAP_TYPE_Damis__SAMANN (30)
/* Damis:SAMANN */
struct Damis__SAMANN
{
public:
	std::string X;	/* required element of type xsd:string */
	int d;	/* required element of type xsd:int */
	int maxIteration;	/* required element of type xsd:int */
	double mTrain;	/* required element of type xsd:double */
	int nNeurons;	/* required element of type xsd:int */
	double eta;	/* required element of type xsd:double */
	int p;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 30; } /* = unique id SOAP_TYPE_Damis__SAMANN */
};
#endif

#ifndef SOAP_TYPE_Damis__SOMResponse
#define SOAP_TYPE_Damis__SOMResponse (31)
/* Damis:SOMResponse */
struct Damis__SOMResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 31; } /* = unique id SOAP_TYPE_Damis__SOMResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__SOM
#define SOAP_TYPE_Damis__SOM (34)
/* Damis:SOM */
struct Damis__SOM
{
public:
	std::string X;	/* required element of type xsd:string */
	int rows;	/* required element of type xsd:int */
	int columns;	/* required element of type xsd:int */
	int eHat;	/* required element of type xsd:int */
	int p;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 34; } /* = unique id SOAP_TYPE_Damis__SOM */
};
#endif

#ifndef SOAP_TYPE_Damis__SOMMDSResponse
#define SOAP_TYPE_Damis__SOMMDSResponse (35)
/* Damis:SOMMDSResponse */
struct Damis__SOMMDSResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmErrorQuantization;	/* required element of type xsd:double */
	double algorithmErrorMDS;	/* required element of type xsd:double */
public:
	int soap_type() const { return 35; } /* = unique id SOAP_TYPE_Damis__SOMMDSResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__SOMMDS
#define SOAP_TYPE_Damis__SOMMDS (38)
/* Damis:SOMMDS */
struct Damis__SOMMDS
{
public:
	std::string X;	/* required element of type xsd:string */
	int rows;	/* required element of type xsd:int */
	int columns;	/* required element of type xsd:int */
	int eHat;	/* required element of type xsd:int */
	int mdsIteration;	/* required element of type xsd:int */
	double eps;	/* required element of type xsd:double */
	int mdsProjection;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 38; } /* = unique id SOAP_TYPE_Damis__SOMMDS */
};
#endif

#ifndef SOAP_TYPE_Damis__MLPResponse
#define SOAP_TYPE_Damis__MLPResponse (39)
/* Damis:MLPResponse */
struct Damis__MLPResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 39; } /* = unique id SOAP_TYPE_Damis__MLPResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__MLP
#define SOAP_TYPE_Damis__MLP (42)
/* Damis:MLP */
struct Damis__MLP
{
public:
	std::string X;	/* required element of type xsd:string */
	int h1pNo;	/* required element of type xsd:int */
	int h2pNo;	/* required element of type xsd:int */
	int h3pNo;	/* required element of type xsd:int */
	double dL;	/* required element of type xsd:double */
	double dT;	/* required element of type xsd:double */
	double dV;	/* required element of type xsd:double */
	int maxIteration;	/* required element of type xsd:int */
	int p;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 42; } /* = unique id SOAP_TYPE_Damis__MLP */
};
#endif

#ifndef SOAP_TYPE_Damis__C45Response
#define SOAP_TYPE_Damis__C45Response (43)
/* Damis:C45Response */
struct Damis__C45Response
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	double algorithmError;	/* required element of type xsd:double */
public:
	int soap_type() const { return 43; } /* = unique id SOAP_TYPE_Damis__C45Response */
};
#endif

#ifndef SOAP_TYPE_Damis__C45
#define SOAP_TYPE_Damis__C45 (46)
/* Damis:C45 */
struct Damis__C45
{
public:
	std::string X;	/* required element of type xsd:string */
	double q;	/* required element of type xsd:double */
	double dL;	/* required element of type xsd:double */
	double dT;	/* required element of type xsd:double */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 46; } /* = unique id SOAP_TYPE_Damis__C45 */
};
#endif

#ifndef SOAP_TYPE_Damis__KMEANSResponse
#define SOAP_TYPE_Damis__KMEANSResponse (47)
/* Damis:KMEANSResponse */
struct Damis__KMEANSResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
	int kBest;	/* required element of type xsd:int */
public:
	int soap_type() const { return 47; } /* = unique id SOAP_TYPE_Damis__KMEANSResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__KMEANS
#define SOAP_TYPE_Damis__KMEANS (50)
/* Damis:KMEANS */
struct Damis__KMEANS
{
public:
	std::string X;	/* required element of type xsd:string */
	int kMax;	/* required element of type xsd:int */
	int maxIteration;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 50; } /* = unique id SOAP_TYPE_Damis__KMEANS */
};
#endif

#ifndef SOAP_TYPE_Damis__STATPRIMITIVESResponse
#define SOAP_TYPE_Damis__STATPRIMITIVESResponse (51)
/* Damis:STATPRIMITIVESResponse */
struct Damis__STATPRIMITIVESResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 51; } /* = unique id SOAP_TYPE_Damis__STATPRIMITIVESResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__STATPRIMITIVES
#define SOAP_TYPE_Damis__STATPRIMITIVES (54)
/* Damis:STATPRIMITIVES */
struct Damis__STATPRIMITIVES
{
public:
	std::string X;	/* required element of type xsd:string */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 54; } /* = unique id SOAP_TYPE_Damis__STATPRIMITIVES */
};
#endif

#ifndef SOAP_TYPE_Damis__CLEANDATAResponse
#define SOAP_TYPE_Damis__CLEANDATAResponse (55)
/* Damis:CLEANDATAResponse */
struct Damis__CLEANDATAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 55; } /* = unique id SOAP_TYPE_Damis__CLEANDATAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__CLEANDATA
#define SOAP_TYPE_Damis__CLEANDATA (58)
/* Damis:CLEANDATA */
struct Damis__CLEANDATA
{
public:
	std::string X;	/* required element of type xsd:string */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 58; } /* = unique id SOAP_TYPE_Damis__CLEANDATA */
};
#endif

#ifndef SOAP_TYPE_Damis__FILTERDATAResponse
#define SOAP_TYPE_Damis__FILTERDATAResponse (59)
/* Damis:FILTERDATAResponse */
struct Damis__FILTERDATAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 59; } /* = unique id SOAP_TYPE_Damis__FILTERDATAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__FILTERDATA
#define SOAP_TYPE_Damis__FILTERDATA (62)
/* Damis:FILTERDATA */
struct Damis__FILTERDATA
{
public:
	std::string X;	/* required element of type xsd:string */
	bool retFilteredData;	/* required element of type xsd:boolean */
	double zValue;	/* required element of type xsd:double */
	int attrIndex;	/* required element of type xsd:int */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 62; } /* = unique id SOAP_TYPE_Damis__FILTERDATA */
};
#endif

#ifndef SOAP_TYPE_Damis__SPLITDATAResponse
#define SOAP_TYPE_Damis__SPLITDATAResponse (63)
/* Damis:SPLITDATAResponse */
struct Damis__SPLITDATAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	std::string Yalt;	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 63; } /* = unique id SOAP_TYPE_Damis__SPLITDATAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__SPLITDATA
#define SOAP_TYPE_Damis__SPLITDATA (66)
/* Damis:SPLITDATA */
struct Damis__SPLITDATA
{
public:
	std::string X;	/* required element of type xsd:string */
	bool reshufleObjects;	/* required element of type xsd:boolean */
	double firstSubsetPerc;	/* required element of type xsd:double */
	double secondSubsetPerc;	/* required element of type xsd:double */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 66; } /* = unique id SOAP_TYPE_Damis__SPLITDATA */
};
#endif

#ifndef SOAP_TYPE_Damis__TRANSPOSEDATAResponse
#define SOAP_TYPE_Damis__TRANSPOSEDATAResponse (67)
/* Damis:TRANSPOSEDATAResponse */
struct Damis__TRANSPOSEDATAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 67; } /* = unique id SOAP_TYPE_Damis__TRANSPOSEDATAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__TRANSPOSEDATA
#define SOAP_TYPE_Damis__TRANSPOSEDATA (70)
/* Damis:TRANSPOSEDATA */
struct Damis__TRANSPOSEDATA
{
public:
	std::string X;	/* required element of type xsd:string */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 70; } /* = unique id SOAP_TYPE_Damis__TRANSPOSEDATA */
};
#endif

#ifndef SOAP_TYPE_Damis__NORMDATAResponse
#define SOAP_TYPE_Damis__NORMDATAResponse (71)
/* Damis:NORMDATAResponse */
struct Damis__NORMDATAResponse
{
public:
	std::string Y;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of type xsd:string */
	double calcTime;	/* required element of type xsd:double */
public:
	int soap_type() const { return 71; } /* = unique id SOAP_TYPE_Damis__NORMDATAResponse */
};
#endif

#ifndef SOAP_TYPE_Damis__NORMDATA
#define SOAP_TYPE_Damis__NORMDATA (74)
/* Damis:NORMDATA */
struct Damis__NORMDATA
{
public:
	std::string X;	/* required element of type xsd:string */
	bool normMeanStd;	/* required element of type xsd:boolean */
	double a;	/* required element of type xsd:double */
	double b;	/* required element of type xsd:double */
	int maxCalcTime;	/* required element of type xsd:int */
public:
	int soap_type() const { return 74; } /* = unique id SOAP_TYPE_Damis__NORMDATA */
};
#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (75)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 75; } /* = unique id SOAP_TYPE_SOAP_ENV__Header */
#ifdef WITH_NOEMPTYSTRUCT
private:
	char dummy;	/* dummy member to enable compilation */
#endif
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (76)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
public:
	int soap_type() const { return 76; } /* = unique id SOAP_TYPE_SOAP_ENV__Code */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (78)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
public:
	int soap_type() const { return 78; } /* = unique id SOAP_TYPE_SOAP_ENV__Detail */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (81)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
public:
	int soap_type() const { return 81; } /* = unique id SOAP_TYPE_SOAP_ENV__Reason */
};
#endif

#endif

#ifndef WITH_NOGLOBAL

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (82)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
public:
	int soap_type() const { return 82; } /* = unique id SOAP_TYPE_SOAP_ENV__Fault */
};
#endif

#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


#endif

/* End of soapStub.h */
